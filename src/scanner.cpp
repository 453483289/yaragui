#include "scanner.h"
#include <yara.h>
#include <sstream>

Scanner::~Scanner()
{
  m_io.stop();
  m_thread->join();
}

Scanner::Scanner(boost::asio::io_service& caller) : m_caller(caller), m_scanRunning(false), m_scanAborted(false)
{
  m_thread = boost::make_shared<boost::thread>(boost::bind(&Scanner::thread, this));
}

void Scanner::compile(const std::string& file, const std::string& ns, boost::function<void (CompileResult::Ref result)> callback)
{
  m_io.post(boost::bind(&Scanner::threadCompile, this, file, ns, callback));
}

bool Scanner::scanStart(YR_RULES* rules, const std::string& file, int timeout, ScanResultCallback resultCallback, ScanCompleteCallback completeCallback)
{
  if (m_scanRunning) {
    return false;
  }
  m_io.post(boost::bind(&Scanner::threadScanStart, this, rules, file, timeout, resultCallback, completeCallback));
  return true;
}

void Scanner::scanStop()
{
  m_scanAborted = true;
}

void Scanner::threadCompile(const std::string& file, const std::string& ns, boost::function<void (CompileResult::Ref result)> callback)
{
  CompileResult::Ref result = boost::make_shared<CompileResult>();
  result->rules = 0;
  result->file = file;
  result->ns = ns;

  FILE* fd = fopen(file.c_str(), "r");
  if (!fd) {
    result->error = "Failed to compile rules: Error loading file: \"" + file + "\"";
    m_caller.post(boost::bind(callback, result));
    return;
  }

  YR_COMPILER* compiler = 0;
  int createResult = yr_compiler_create(&compiler);
  if (createResult != ERROR_SUCCESS) {
    result->error = "Failed to compile rules: " + yaraErrorToString(createResult);
    fclose(fd);
    m_caller.post(boost::bind(callback, result));
    return;
  }

  yr_compiler_set_callback(compiler, yaraCompilerCallback, &result->compilerMessages);
  int errorCount = yr_compiler_add_file(compiler, fd, ns.c_str(), file.c_str());
  fclose(fd);

  if (errorCount) {
    result->error = "Failed to compile rules: Rules contain errors.";
    yr_compiler_destroy(compiler);
    m_caller.post(boost::bind(callback, result));
    return;
  }

  int rulesResult = yr_compiler_get_rules(compiler, &result->rules);
  yr_compiler_destroy(compiler);

  if (rulesResult != ERROR_SUCCESS) {
    result->error = "Failed to compile rules: " + yaraErrorToString(createResult);
    m_caller.post(boost::bind(callback, result));
    return;
  }

  m_caller.post(boost::bind(callback, result)); /* compile success */
}

void Scanner::threadScanStart(YR_RULES* rules, const std::string& file, int timeout, ScanResultCallback resultCallback, ScanCompleteCallback completeCallback)
{
  m_scanResultCallback = resultCallback;
  m_scanRunning = true;
  m_scanAborted = false;

  int scanResult = yr_rules_scan_file(rules, file.c_str(), 0, yaraScanCallback, this, timeout);

  std::string error;
  if (scanResult != ERROR_SUCCESS && scanResult) {
    error = yaraErrorToString(scanResult);
  }

  m_caller.post(boost::bind(completeCallback, error));

  m_scanRunning = false;
}

void Scanner::thread()
{
  /* initialize YARA for this thread */

  m_yaraInitStatus = yr_initialize();

  boost::asio::io_service::work keepAlive(m_io);
  m_io.run();

  if (m_yaraInitStatus == ERROR_SUCCESS) {
    yr_finalize();
  }
}

int Scanner::yaraScanCallback(int message, void* messageData, void* userData)
{
  Scanner* scanner = (Scanner*)userData;

  if (message == CALLBACK_MSG_RULE_NOT_MATCHING) {
    /* this is just to indicate scan progress */
    scanner->m_caller.post(boost::bind(scanner->m_scanResultCallback, ScannerRule::Ref()));
  }

  if (message == CALLBACK_MSG_RULE_MATCHING) {
    ScannerRule::Ref rule = boost::make_shared<ScannerRule>((YR_RULE*)messageData);
    scanner->m_caller.post(boost::bind(scanner->m_scanResultCallback, rule));
  }

  if (scanner->m_scanAborted) {
    return CALLBACK_ABORT;
  }

  return CALLBACK_CONTINUE;
}

void Scanner::yaraCompilerCallback(int errorLevel, const char* fileName, int lineNumber, const char* message, void* userData)
{
  std::string& result = *(std::string*)&userData;
  std::stringstream ss;
  ss << fileName << "(" << lineNumber << "): error: " << message << std::endl;
  result += ss.str();
}

std::string Scanner::yaraErrorToString(const int code) const
{
  switch (code) {
  case ERROR_SUCCESS:
    return "Everything went fine.";
  case ERROR_INSUFICIENT_MEMORY:
    return "Insuficient memory to complete the operation.";
  case ERROR_COULD_NOT_OPEN_FILE:
    return "File could not be opened.";
  case ERROR_COULD_NOT_MAP_FILE:
    return "File could not be mapped into memory.";
  case ERROR_INVALID_FILE:
    return "File is not a valid rules file.";
  case ERROR_CORRUPT_FILE:
    return "Rules file is corrupt.";
  case ERROR_UNSUPPORTED_FILE_VERSION:
    return "File was generated by a different version and canâ€™t be loaded.";
  case ERROR_TOO_MANY_SCAN_THREADS:
    return "Too many threads trying to scan simultaneously";
  case ERROR_SCAN_TIMEOUT:
    return "Scan timed out.";
  case ERROR_CALLBACK_ERROR:
    return "Callback returned an error.";
  case ERROR_TOO_MANY_MATCHES:
    return "Too many matches for some string in your rules. This usually happens when your rules contains very short or very common strings like 01 02 or FF FF FF FF.";
  default:
    break;
  }
  /* output error code for unknown errors */
  std::stringstream ss;
  ss << "Unknown error (" << code << ").";
  return ss.str();
}
